<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Tournoi Baby-Foot — Multi-modes</title>
<style>
  body{font-family:system-ui,Arial,Helvetica,sans-serif;margin:14px;background:#f3f7fb;color:#0b1a2b}
  .wrap{max-width:980px;margin:0 auto}
  h1{text-align:center;color:#0b66c2;margin-bottom:8px}
  h2{margin-top:0}
  .card{background:#fff;border-radius:8px;padding:14px;margin:12px 0;box-shadow:0 2px 8px rgba(0,0,0,0.06)}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-bottom:8px}
  input,select,button{padding:8px;border-radius:6px;border:1px solid #cbd5e1;font-size:14px}
  button{cursor:pointer;background:#2563eb;color:white;border:none}
  button.secondary{background:#0f172a;color:#e5e7eb}
  button.warn{background:#f59e0b;color:#111}
  button.danger{background:#dc2626}
  .muted{color:#64748b;font-size:13px}
  .pill{display:inline-block;padding:6px 10px;border-radius:999px;background:#eef2ff;margin:3px;border:1px solid #c7d2fe}
  .match{border:1px solid #e2e8f0;padding:10px;border-radius:6px;margin:8px 0;background:#ffffff}
  .badge{display:inline-block;padding:4px 8px;border-radius:999px;background:#e6eef8;margin-right:8px;font-size:12px}
  .help{font-size:13px;color:#475569}
  table{width:100%;border-collapse:collapse;margin-top:8px}
  th,td{border:1px solid #e2e8f0;padding:6px;text-align:center;font-size:13px}
  th{background:#f8fafc}
  pre{background:#f1f5f9;padding:8px;border-radius:6px;max-height:260px;overflow:auto;font-size:11px}
  .mode-btn{flex:1;min-width:140px;font-size:16px;padding:12px}
  .hidden{display:none}
  #historyPanel{display:none;margin-top:8px}
  @media(max-width:600px){ .row{flex-direction:column;align-items:stretch} }
</style>
</head>
<body>
<div class="wrap">
  <h1>Tournoi Baby-Foot — Monster DYP & Open Double</h1>

  <!-- Écran de choix du mode -->
  <section id="modeScreen" class="card">
    <h2>Choix du mode</h2>
    <p class="muted">Sélectionne le type de tournoi que tu veux lancer.</p>
    <div class="row">
      <button id="btnModeDYP" class="mode-btn">Monster DYP</button>
      <button id="btnModeOpen" class="mode-btn secondary">Open Double (Système Suisse)</button>
    </div>
  </section>

  <!-- MODE DYP -->
  <div id="dypSection" class="hidden">
    <section class="card">
      <h2>[DYP] 1) Inscriptions joueurs</h2>
      <div class="row">
        <input id="dypPlayerName" placeholder="Nom du joueur" />
        <select id="dypPlayerRole">
          <option>Attaquant</option>
          <option>Défenseur</option>
          <option>Polyvalent</option>
        </select>
        <button id="dypBtnAdd">Ajouter</button>
        <button id="dypBtnReset" class="danger">Réinitialiser DYP</button>
      </div>
      <div id="dypPlayersList" class="muted">Aucun joueur</div>
    </section>

    <section class="card">
      <h2>[DYP] 2) Qualifications — DYP 2 vs 2</h2>
      <div class="row">
        <button id="dypBtnNewRound">Nouvelle manche</button>
        <span id="dypRoundInfo" class="muted"></span>
      </div>
      <div id="dypQualifMatches"></div>

      <h3>Classement DYP</h3>
      <div id="dypRanking"></div>
    </section>

    <section class="card">
      <h2>[DYP] 3) Phase finale — Double élimination 2 vs 2 (recomposée)</h2>
      <div class="row">
        <label>Nombre de qualifiés :
          <input id="dypFinalCount" type="number" value="8" min="4" step="4" style="width:90px;margin-left:6px">
        </label>
        <button id="dypBtnStartFinals" style="background:#16a34a">Démarrer la phase finale DYP</button>
        <button id="dypBtnForceNext" class="warn">Forcer avancée</button>
      </div>
      <div class="help">Valide tous les matchs d'un round (WB ou LB) pour générer le round suivant. Si ça bloque, utilise « Forcer avancée ».</div>
      <div id="dypFinalsArea"></div>
    </section>
  </div>

  <!-- MODE OPEN DOUBLE -->
  <div id="openSection" class="hidden">
    <section class="card">
      <h2>[OPEN] 1) Inscriptions équipes</h2>
      <div class="row">
        <input id="openTeamName" placeholder="Nom de l'équipe (ex: Jean & Pierre)" />
        <button id="openBtnAdd">Ajouter équipe</button>
        <button id="openBtnReset" class="danger">Réinitialiser Open Double</button>
      </div>
      <div id="openTeamsList" class="muted">Aucune équipe</div>
    </section>

    <section class="card">
      <h2>[OPEN] 2) Qualifications — Système Suisse (4 rondes)</h2>
      <div class="row">
        <button id="openBtnNewRound">Lancer la ronde suivante</button>
        <span id="openRoundInfo" class="muted"></span>
      </div>
      <div id="openQualifMatches"></div>

      <h3>Classement Open Double</h3>
      <div id="openRanking"></div>
    </section>

    <section class="card">
      <h2>[OPEN] 3) Phases finales — Tableaux A & B (double élimination)</h2>
      <div class="row">
        <button id="openBtnStartFinals" style="background:#16a34a">Créer tableaux A & B</button>
        <button id="openBtnForceNext" class="warn">Forcer avancée</button>
      </div>
      <div class="help">
        Après les 4 rondes, les équipes sont divisées : Tableau A (meilleure moitié, +1 si impair) et Tableau B (seconde moitié).<br>
        Chaque tableau a son Winners/Losers bracket.
      </div>
      <div id="openFinalsArea"></div>
    </section>
  </div>

  <!-- HISTORIQUE GLOBAL -->
  <section class="card">
    <h2>Historique global des matchs</h2>
    <button id="btnToggleHistory" class="secondary">Afficher / masquer l'historique</button>
    <div id="historyPanel">
      <div id="historyEmpty" class="muted">Aucun match encore joué.</div>
      <ol id="historyList" class="muted"></ol>
    </div>
  </section>

  <!-- DEBUG -->
  <section class="card">
    <h2>Debug (état interne, erreurs)</h2>
    <div class="muted">En cas de blocage, ce bloc peut montrer une erreur JavaScript ou l'état d'un bracket.</div>
    <pre id="debugBox">--</pre>
  </section>
</div>

<script>
// ----------- Global error catcher -----------
window.onerror = function(message, source, line, col, err){
  const dbg = document.getElementById('debugBox');
  if(dbg){
    dbg.textContent = (message || 'Erreur') + ' — ' + (source||'') + ':' + line + ':' + col + '\\n' + (err && err.stack ? err.stack : '');
  }
  console.error(message, source, line, col, err);
  return false;
};

// ----------- Helpers et historique global -----------
const el = id => document.getElementById(id);
const randId = ()=> Math.random().toString(36).slice(2,9);
const shuffle = arr => arr.sort(()=>Math.random()-0.5);

let globalHistory = []; // {mode, phase, label, score}

function addHistoryEntry(mode, phase, label, scoreA, scoreB){
  let txt = `[${mode} - ${phase}] ${label}`;
  if(scoreA!=null && scoreB!=null){
    txt += ` — ${scoreA} : ${scoreB}`;
  }
  globalHistory.push(txt);
  renderGlobalHistory();
}

function renderGlobalHistory(){
  const panel = el('historyPanel');
  const list = el('historyList');
  const empty = el('historyEmpty');
  if(!globalHistory.length){
    empty.style.display = 'block';
    list.innerHTML = '';
  } else {
    empty.style.display = 'none';
    list.innerHTML = globalHistory.map(s=>`<li>${s}</li>`).join('');
  }
}

// ----------- MODE SWITCH -----------
let currentMode = null;
function showMode(mode){
  currentMode = mode;
  el('modeScreen').classList.add('hidden');
  el('dypSection').classList.add('hidden');
  el('openSection').classList.add('hidden');
  if(mode === 'dyp') el('dypSection').classList.remove('hidden');
  if(mode === 'open') el('openSection').classList.remove('hidden');
}

// ----------- DYP STATE -----------
let dPlayers = [];   // {name, role}
let dStats = {};     // name -> {W,D,GF,GA,byeCount}
let dRound = 0;
let dMatches = [];   // {id,round,teamA[],teamB[],scoreA,scoreB,done}
let dUsedPairs = {};
let dUsedMatchups = {};
let dFinals = null;  // double elim structure pour DYP

function dEnsurePlayer(n){ if(!dStats[n]) dStats[n] = {W:0,D:0,GF:0,GA:0,byeCount:0}; }
function dPairKey(A,B){
  const t1 = A.slice().sort().join('&');
  const t2 = B.slice().sort().join('&');
  return [t1,t2].sort().join('|');
}

function dRenderPlayers(){
  el('dypPlayersList').innerHTML = dPlayers.length
    ? dPlayers.map(p=>`<span class="pill">${p.name} (${p.role})</span>`).join('')
    : '<span class="muted">Aucun joueur</span>';
}
function dRenderRanking(){
  const rows = Object.entries(dStats).map(([name,s])=>({name,...s}));
  rows.sort((a,b)=>{
    if(b.W!==a.W) return b.W - a.W;
    const gda = a.GF-a.GA, gdb = b.GF-b.GA;
    if(gdb!==gda) return gdb-gda;
    return b.GF-a.GF;
  });
  let html = '<table><tr><th>Rang</th><th>Joueur</th><th>V</th><th>D</th><th>GF</th><th>GA</th><th>GD</th></tr>';
  rows.forEach((r,i)=>{
    html += `<tr><td>${i+1}</td><td>${r.name}</td><td>${r.W||0}</td><td>${r.D||0}</td><td>${r.GF||0}</td><td>${r.GA||0}</td><td>${(r.GF||0)-(r.GA||0)}</td></tr>`;
  });
  html += '</table>';
  el('dypRanking').innerHTML = html;
}

function dBuildTeams(){
  const attackers = dPlayers.filter(p=>p.role==='Attaquant' || p.role==='Polyvalent').map(p=>p.name);
  const defenders = dPlayers.filter(p=>p.role==='Défenseur' || p.role==='Polyvalent').map(p=>p.name);
  let candidates = [];
  attackers.forEach(a=>defenders.forEach(d=>{
    if(a!==d){
      const key = [a,d].sort().join('&');
      candidates.push({a,d,used: dUsedPairs[key]||0});
    }
  }));
  shuffle(candidates);
  candidates.sort((x,y)=>x.used-y.used);
  const used = new Set();
  const teams = [];
  candidates.forEach(c=>{
    if(used.has(c.a) || used.has(c.d)) return;
    teams.push([c.a,c.d]);
    used.add(c.a); used.add(c.d);
  });
  const leftovers = dPlayers.map(p=>p.name).filter(n=>!used.has(n));
  while(leftovers.length>=2){
    const a = leftovers.pop();
    const b = leftovers.pop();
    teams.push([a,b]);
  }
  return teams;
}

function dChooseByeTeam(teams){
  if(!teams.length) return null;
  let best = Infinity, idx = 0;
  teams.forEach((t,i)=>{
    dEnsurePlayer(t[0]); dEnsurePlayer(t[1]);
    const s = (dStats[t[0]].byeCount||0)+(dStats[t[1]].byeCount||0);
    if(s<best){best=s;idx=i;}
  });
  return teams.splice(idx,1)[0];
}

function dPairTeams(teams){
  let best = null, bestScore = Infinity;
  for(let k=0;k<60;k++){
    const arr = teams.slice(); shuffle(arr);
    let score = 0; const pairs = [];
    for(let i=0;i<arr.length;i+=2){
      const A=arr[i], B=arr[i+1];
      const key = dPairKey(A,B);
      score += (dUsedMatchups[key]||0);
      pairs.push([A,B]);
    }
    if(score<bestScore){bestScore=score;best=pairs;if(score===0)break;}
  }
  return best;
}

function dRenderQualifMatches(){
  const node = el('dypQualifMatches'); node.innerHTML='';
  const current = dMatches.filter(m=>m.round===dRound);
  if(!current.length){
    node.innerHTML = '<div class="muted">Aucun match généré pour cette manche.</div>';
    return;
  }
  current.forEach((m,i)=>{
    const id = m.id;
    const d = document.createElement('div'); d.className='match';
    d.innerHTML = `<div><span class="badge">DYP Qualif</span> <b>Match ${m.round}.${i+1}</b></div>
      <div>${m.teamA.join(' & ')} <b>vs</b> ${m.teamB.join(' & ')}</div>
      <div class="row">
        <input id="dA_${id}" type="number" min="0" placeholder="0"> - 
        <input id="dB_${id}" type="number" min="0" placeholder="0">
        <button>Valider</button>
      </div>`;
    d.querySelector('button').onclick = ()=> dSubmitQualif(id);
    node.appendChild(d);
  });
}

function dGenerateRound(){
  if(dPlayers.length<4){ alert('Au moins 4 joueurs DYP requis.'); return; }
  dRound++;
  el('dypRoundInfo').textContent = 'Manche ' + dRound;
  let teams = dBuildTeams();
  let copy = teams.slice();
  if(copy.length % 2 === 1){
    const byeTeam = dChooseByeTeam(copy);
    byeTeam.forEach(n=>{
      dEnsurePlayer(n);
      dStats[n].W++;
      dStats[n].byeCount = (dStats[n].byeCount||0)+1;
    });
    addHistoryEntry('DYP','Qualif BYE', byeTeam.join(' & ')+' (BYE)', null, null);
  }
  const pairs = dPairTeams(copy);
  pairs.forEach(pair=>{
    const [tA,tB] = pair;
    const keyA = tA.slice().sort().join('&');
    const keyB = tB.slice().sort().join('&');
    dUsedPairs[keyA]=(dUsedPairs[keyA]||0)+1;
    dUsedPairs[keyB]=(dUsedPairs[keyB]||0)+1;
    const matchId = 'DQ_'+randId();
    dMatches.push({id:matchId,round:dRound,teamA:tA,teamB:tB,scoreA:null,scoreB:null,done:false});
  });
  dRenderQualifMatches();
  dRenderRanking();
}

function dSubmitQualif(id){
  const m = dMatches.find(x=>x.id===id);
  if(!m || m.done) return;
  const a = parseInt(el('dA_'+id).value||'0',10);
  const b = parseInt(el('dB_'+id).value||'0',10);
  if(a<11 && b<11){ alert('Un score doit atteindre 11.'); return; }
  m.scoreA=a; m.scoreB=b; m.done=true;
  const winner = a>b ? m.teamA : m.teamB;
  const loser  = a>b ? m.teamB : m.teamA;
  winner.forEach(n=>{
    dEnsurePlayer(n);
    dStats[n].W++; dStats[n].GF += Math.max(a,b); dStats[n].GA += Math.min(a,b);
  });
  loser.forEach(n=>{
    dEnsurePlayer(n);
    dStats[n].D++; dStats[n].GF += Math.min(a,b); dStats[n].GA += Math.max(a,b);
  });
  const key = dPairKey(m.teamA,m.teamB);
  dUsedMatchups[key]=(dUsedMatchups[key]||0)+1;
  addHistoryEntry('DYP','Qualif R'+m.round, m.teamA.join(' & ')+' vs '+m.teamB.join(' & '), a,b);
  dRenderQualifMatches();
  dRenderRanking();
}

// ---------- DYP FINALS (double élimination recomposée) ----------
function dTeamsToMatches(teams, roundNum, type){
  const arr = [];
  for(let i=0;i<teams.length;i+=2){
    const A = teams[i], B = teams[i+1];
    if(!B) continue;
    arr.push({ id:randId(), type, round: roundNum, teamA:A, teamB:B, scoreA:null, scoreB:null, done:false });
  }
  return arr;
}

function dStartFinals(){
  const N = parseInt(el('dypFinalCount').value,10);
  const ranked = Object.entries(dStats).map(([name,s])=>({name,...s}))
    .sort((a,b)=>{
      if(b.W!==a.W) return b.W-a.W;
      const gda=a.GF-a.GA, gdb=b.GF-b.GA;
      if(gdb!==gda) return gdb-gda;
      return b.GF-a.GF;
    });
  if(ranked.length<4){ alert('Pas assez de joueurs pour la phase finale DYP.'); return; }
  let selected = ranked.slice(0,N).map(r=>r.name);
  if(selected.length%2!==0) selected.pop();
  const sh = shuffle(selected.slice());
  const teams = [];
  for(let i=0;i<sh.length;i+=2) teams.push([sh[i],sh[i+1]]);
  const tCount = teams.length;
  if((tCount & (tCount-1)) !== 0){ alert("Le nombre d'équipes finales DYP doit être une puissance de 2 (4,8,16...)."); return; }
  dFinals = { WB:{rounds:[]}, LB:{rounds:[]}, GF:[], _pendingWB:{}, _pendingLB_fromWB:{}, _pendingLBWin:{} };
  dFinals.WB.rounds.push( dTeamsToMatches(teams,1,'W') );
  dRenderFinals();
  alert('Phase finale DYP initialisée.');
}

function dFindFinalMatch(uid){
  if(!dFinals) return null;
  if(uid.startsWith('W')){
    const parts = uid.split('_'); const r = parseInt(parts[0].slice(1),10)-1; const id = parts[1];
    const arr = dFinals.WB.rounds[r]||[]; return {match:arr.find(m=>m.id===id), bracket:'W', r};
  }
  if(uid.startsWith('L')){
    const parts = uid.split('_'); const r = parseInt(parts[0].slice(1),10)-1; const id = parts[1];
    const arr = dFinals.LB.rounds[r]||[]; return {match:arr.find(m=>m.id===id), bracket:'L', r};
  }
  if(uid.startsWith('F')){
    const parts = uid.split('_'); const idx = parseInt(parts[0].slice(1),10);
    return {match:dFinals.GF[idx], bracket:'F', r:idx};
  }
  return null;
}

function dSubmitFinal(uid){
  const meta = dFindFinalMatch(uid);
  if(!meta || !meta.match) return alert('Match introuvable.');
  const m = meta.match;
  if(m.done) return;
  const a = parseInt(el('dFA_'+uid).value||'0',10);
  const b = parseInt(el('dFB_'+uid).value||'0',10);
  if(a<11 && b<11){ alert('Un score doit atteindre 11.'); return; }
  m.scoreA=a; m.scoreB=b; m.done=true;
  const winnerTeam = a>b ? m.teamA.slice() : m.teamB.slice();
  const loserTeam  = a>b ? m.teamB.slice() : m.teamA.slice();
  addHistoryEntry('DYP', meta.bracket==='W' ? ('WB R'+(meta.r+1)) : meta.bracket==='L' ? ('LB R'+(meta.r+1)) : 'Finale', m.teamA.join(' & ')+' vs '+m.teamB.join(' & '), a,b);

  if(meta.bracket==='W'){
    dFinals._pendingWB[meta.r] = dFinals._pendingWB[meta.r]||[];
    dFinals._pendingLB_fromWB[meta.r] = dFinals._pendingLB_fromWB[meta.r]||[];
    dFinals._pendingWB[meta.r].push(winnerTeam);
    dFinals._pendingLB_fromWB[meta.r].push(loserTeam);
    const allDone = dFinals.WB.rounds[meta.r].every(x=>x.done);
    if(allDone) dHandleWBRoundComplete(meta.r);
  } else if(meta.bracket==='L'){
    dFinals._pendingLBWin[meta.r] = dFinals._pendingLBWin[meta.r]||[];
    dFinals._pendingLBWin[meta.r].push(winnerTeam);
    const arr = dFinals.LB.rounds[meta.r]||[];
    const allDone = arr.length>0 && arr.every(x=>x.done);
    if(allDone) dHandleLBRoundComplete(meta.r);
  } else if(meta.bracket==='F'){
    const idx = meta.r;
    if(idx===0){
      const lbWon = winnerTeam.join(',') === m.teamB.join(',');
      if(lbWon){
        dFinals.GF.push({ id:randId(), type:'F', round:2, teamA:m.teamB, teamB:m.teamA, scoreA:null, scoreB:null, done:false });
        alert('LB gagne la première finale DYP — deuxième finale ajoutée.');
      } else {
        alert('Vainqueur DYP : '+winnerTeam.join(' & '));
      }
    } else {
      alert('Vainqueur DYP : '+winnerTeam.join(' & '));
    }
  }
  dMaybeCreateGrandFinal();
  dRenderFinals();
}

function dHandleWBRoundComplete(roundIdx){
  const winners = (dFinals._pendingWB[roundIdx]||[]).slice();
  dFinals._pendingWB[roundIdx]=[];
  const nextTeams = [];
  for(let i=0;i<winners.length;i+=2){
    const t1 = winners[i], t2 = winners[i+1];
    if(!t1||!t2) continue;
    nextTeams.push([t1[0], t2[0]]);
    nextTeams.push([t1[1], t2[1]]);
  }
  if(nextTeams.length){
    dFinals.WB.rounds[roundIdx+1] = dFinals.WB.rounds[roundIdx+1]||[];
    dFinals.WB.rounds[roundIdx+1] = dFinals.WB.rounds[roundIdx+1].concat( dTeamsToMatches(nextTeams, roundIdx+2,'W') );
  }
  const losers = (dFinals._pendingLB_fromWB[roundIdx]||[]).slice();
  dFinals._pendingLB_fromWB[roundIdx]=[];
  if(losers.length){
    dFinals.LB.rounds[0] = dFinals.LB.rounds[0]||[];
    for(let i=0;i<losers.length;i+=2){
      const aT = losers[i], bT = losers[i+1];
      if(aT&&bT){
        dFinals.LB.rounds[0].push({ id:randId(), type:'L', round:1, teamA:aT, teamB:bT, scoreA:null, scoreB:null, done:false });
      }
    }
  }
}

function dHandleLBRoundComplete(roundIdx){
  const wins = (dFinals._pendingLBWin[roundIdx]||[]).slice();
  dFinals._pendingLBWin[roundIdx]=[];
  const nextTeams = [];
  for(let i=0;i<wins.length;i+=2){
    const t1=wins[i], t2=wins[i+1];
    if(!t1||!t2) continue;
    nextTeams.push([t1[0], t2[0]]);
    nextTeams.push([t1[1], t2[1]]);
  }
  if(nextTeams.length){
    dFinals.LB.rounds[roundIdx+1] = dFinals.LB.rounds[roundIdx+1]||[];
    dFinals.LB.rounds[roundIdx+1] = dFinals.LB.rounds[roundIdx+1].concat( dTeamsToMatches(nextTeams, roundIdx+2,'L') );
  }
}

function dMaybeCreateGrandFinal(){
  if(!dFinals) return;
  let wbChamp=null;
  for(let r=dFinals.WB.rounds.length-1;r>=0;r--){
    const rnd=dFinals.WB.rounds[r]||[];
    if(rnd.length===1 && rnd[0].done){
      wbChamp = rnd[0].scoreA>rnd[0].scoreB ? rnd[0].teamA : rnd[0].teamB;
      break;
    }
  }
  let lbChamp=null;
  for(let r=dFinals.LB.rounds.length-1;r>=0;r--){
    const rnd=dFinals.LB.rounds[r]||[];
    if(rnd.length===1 && rnd[0].done){
      lbChamp = rnd[0].scoreA>rnd[0].scoreB ? rnd[0].teamA : rnd[0].teamB;
      break;
    }
  }
  if(wbChamp && lbChamp && (!dFinals.GF || dFinals.GF.length===0)){
    dFinals.GF = [ {id:randId(), type:'F', round:1, teamA:wbChamp, teamB:lbChamp, scoreA:null, scoreB:null, done:false} ];
  }
}

function dForceAdvance(){
  if(!dFinals){ alert('Phase finale DYP non initialisée.'); return; }
  for(let r=0;r<dFinals.WB.rounds.length;r++){
    const arr=dFinals.WB.rounds[r]||[];
    if(arr.length>0 && arr.every(x=>x.done)) dHandleWBRoundComplete(r);
  }
  for(let r=0;r<dFinals.LB.rounds.length;r++){
    const arr=dFinals.LB.rounds[r]||[];
    if(arr.length>0 && arr.every(x=>x.done)) dHandleLBRoundComplete(r);
  }
  dMaybeCreateGrandFinal();
  dRenderFinals();
}

function dRenderFinals(){
  const node = el('dypFinalsArea'); node.innerHTML = '';
  if(!dFinals){
    node.innerHTML = '<div class="muted">Phase finale DYP non initialisée.</div>';
    el('debugBox').textContent = '--';
    return;
  }
  dFinals.WB.rounds.forEach((rnd,ri)=>{
    const r = ri+1;
    rnd.forEach((m,mi)=>{
      const uid = `W${r}_${m.id}`;
      const div = document.createElement('div'); div.className='match';
      div.innerHTML = `<div><span class="badge">[DYP WB R${r} - Match ${mi+1}]</span> ${m.teamA.join(' & ')} vs ${m.teamB.join(' & ')}</div>`;
      const actions = document.createElement('div'); actions.className='row';
      if(!m.done){
        actions.innerHTML = `<input id="dFA_${uid}" type="number" min="0" placeholder="0"> - <input id="dFB_${uid}" type="number" min="0" placeholder="0">
        <button>Valider</button>`;
        actions.querySelector('button').onclick = ()=> dSubmitFinal(uid);
      } else {
        actions.innerHTML = `<div class="muted">Score: ${m.scoreA} - ${m.scoreB}</div>`;
      }
      div.appendChild(actions); node.appendChild(div);
    });
  });
  dFinals.LB.rounds.forEach((rnd,ri)=>{
    const r = ri+1;
    rnd.forEach((m,mi)=>{
      const uid = `L${r}_${m.id}`;
      const div = document.createElement('div'); div.className='match';
      div.innerHTML = `<div><span class="badge">[DYP LB R${r} - Match ${mi+1}]</span> ${m.teamA.join(' & ')} vs ${m.teamB.join(' & ')}</div>`;
      const actions = document.createElement('div'); actions.className='row';
      if(!m.done){
        actions.innerHTML = `<input id="dFA_${uid}" type="number" min="0" placeholder="0"> - <input id="dFB_${uid}" type="number" min="0" placeholder="0">
        <button class="warn">Valider</button>`;
        actions.querySelector('button').onclick = ()=> dSubmitFinal(uid);
      } else {
        actions.innerHTML = `<div class="muted">Score: ${m.scoreA} - ${m.scoreB}</div>`;
      }
      div.appendChild(actions); node.appendChild(div);
    });
  });
  (dFinals.GF||[]).forEach((m,idx)=>{
    const uid=`F${idx}_${m.id}`;
    const div=document.createElement('div'); div.className='match';
    div.innerHTML = `<div><span class="badge">[DYP GF - Match ${idx+1}]</span> ${m.teamA.join(' & ')} vs ${m.teamB.join(' & ')}</div>`;
    const actions=document.createElement('div'); actions.className='row';
    if(!m.done){
      actions.innerHTML=`<input id="dFA_${uid}" type="number" min="0" placeholder="0"> - <input id="dFB_${uid}" type="number" min="0" placeholder="0">
      <button>Valider</button>`;
      actions.querySelector('button').onclick = ()=> dSubmitFinal(uid);
    } else {
      actions.innerHTML=`<div class="muted">Score: ${m.scoreA} - ${m.scoreB}</div>`;
    }
    div.appendChild(actions); node.appendChild(div);
  });
  el('debugBox').textContent = JSON.stringify(dFinals,null,2);
}

// ----------- OPEN DOUBLE STATE -----------
let oTeams = []; // {name, byeCount, pts, gf, ga}
let oRound = 0;
let oMatches = []; // {id,round,teamA,teamB,scoreA,scoreB,done}
let oUsedMatchups = {}; // to avoid rematch
let oFinals = { A:null, B:null };

function oEnsureTeam(t){
  if(!t) return;
  if(typeof t.byeCount==='undefined') t.byeCount=0;
  if(typeof t.pts==='undefined') t.pts=0;
  if(typeof t.gf==='undefined') t.gf=0;
  if(typeof t.ga==='undefined') t.ga=0;
}

function oRenderTeams(){
  el('openTeamsList').innerHTML = oTeams.length
    ? oTeams.map(t=>`<span class="pill">${t.name}</span>`).join('')
    : '<span class="muted">Aucune équipe</span>';
}

function oRenderRanking(){
  const rows = oTeams.slice();
  rows.sort((a,b)=>{
    if(b.pts!==a.pts) return b.pts-a.pts;
    const gda=a.gf-a.ga, gdb=b.gf-b.ga;
    if(gdb!==gda) return gdb-gda;
    return b.gf-a.gf;
  });
  let html = '<table><tr><th>Rang</th><th>Équipe</th><th>Pts</th><th>GF</th><th>GA</th><th>GD</th><th>BYE</th></tr>';
  rows.forEach((t,i)=>{
    html += `<tr><td>${i+1}</td><td>${t.name}</td><td>${t.pts}</td><td>${t.gf}</td><td>${t.ga}</td><td>${t.gf-t.ga}</td><td>${t.byeCount||0}</td></tr>`;
  });
  html+='</table>';
  el('openRanking').innerHTML = html;
}

function oPairKeyNames(a,b){
  const ka = a.name, kb=b.name;
  return [ka,kb].sort().join('|');
}

function oChooseByeTeamSwiss(){
  if(oTeams.length===0) return null;
  let minBye = Infinity;
  oTeams.forEach(t=>{oEnsureTeam(t); if(t.byeCount<minBye)minBye=t.byeCount;});
  const candidates = oTeams.filter(t=>t.byeCount===minBye);
  return candidates[Math.floor(Math.random()*candidates.length)];
}

function oGenerateSwissRound(){
  if(oTeams.length<2){ alert('Au moins 2 équipes requises pour Open Double.'); return; }
  if(oRound>=4){ alert('Les 4 rondes de qualifications sont déjà jouées.'); return; }
  oRound++;
  el('openRoundInfo').textContent = 'Ronde ' + oRound + ' / 4';

  const pool = oTeams.slice().sort((a,b)=>{
    if(b.pts!==a.pts) return b.pts-a.pts;
    const gda=a.gf-a.ga, gdb=b.gf-b.ga;
    if(gdb!==gda) return gdb-gda;
    return 0;
  });

  let byeTeam = null;
  if(pool.length % 2 === 1){
    byeTeam = oChooseByeTeamSwiss();
    if(byeTeam){
      oEnsureTeam(byeTeam);
      byeTeam.pts += 1;
      byeTeam.byeCount += 1;
      addHistoryEntry('OPEN','Qualif BYE', byeTeam.name+' (BYE)', null, null);
      const idx = pool.findIndex(t=>t.name===byeTeam.name);
      if(idx>=0) pool.splice(idx,1);
    }
  }

  const matches = [];
  while(pool.length>1){
    const t1 = pool.shift();
    let bestIdx=-1, bestScore=Infinity;
    for(let i=0;i<pool.length;i++){
      const t2=pool[i];
      const key=oPairKeyNames(t1,t2);
      const used=oUsedMatchups[key]||0;
      if(used<bestScore){bestScore=used;bestIdx=i;}
    }
    const t2 = pool.splice(bestIdx,1)[0];
    matches.push([t1,t2]);
    const key=oPairKeyNames(t1,t2);
    oUsedMatchups[key]=(oUsedMatchups[key]||0)+1;
  }

  matches.forEach(pair=>{
    const [tA,tB]=pair;
    const id='OQ_'+randId();
    oMatches.push({id,round:oRound,teamA:tA,teamB:tB,scoreA:null,scoreB:null,done:false});
  });

  oRenderSwissMatches();
  oRenderRanking();
}

function oRenderSwissMatches(){
  const node = el('openQualifMatches'); node.innerHTML='';
  const current = oMatches.filter(m=>m.round===oRound);
  if(!current.length){
    node.innerHTML='<div class="muted">Aucun match pour cette ronde.</div>';
    return;
  }
  current.forEach((m,i)=>{
    const id=m.id;
    const div=document.createElement('div'); div.className='match';
    div.innerHTML=`<div><span class="badge">OPEN Qualif</span> <b>R${m.round} - Match ${i+1}</b></div>
      <div>${m.teamA.name} <b>vs</b> ${m.teamB.name}</div>
      <div class="row">
        <input id="oA_${id}" type="number" min="0" placeholder="0"> - 
        <input id="oB_${id}" type="number" min="0" placeholder="0">
        <button>Valider</button>
      </div>`;
    div.querySelector('button').onclick=()=>oSubmitSwiss(id);
    node.appendChild(div);
  });
}

function oSubmitSwiss(id){
  const m=oMatches.find(x=>x.id===id);
  if(!m || m.done) return;
  const a=parseInt(el('oA_'+id).value||'0',10);
  const b=parseInt(el('oB_'+id).value||'0',10);
  if(a<11 && b<11){ alert('Un score doit atteindre 11.'); return; }
  m.scoreA=a; m.scoreB=b; m.done=true;
  oEnsureTeam(m.teamA); oEnsureTeam(m.teamB);
  m.teamA.gf += a; m.teamA.ga += b;
  m.teamB.gf += b; m.teamB.ga += a;
  if(a>b) m.teamA.pts +=1;
  else if(b>a) m.teamB.pts +=1;
  addHistoryEntry('OPEN','Qualif R'+m.round, m.teamA.name+' vs '+m.teamB.name, a,b);
  oRenderSwissMatches();
  oRenderRanking();
}

// ---------- OPEN FINALS ----------
function oCreateFinals(){
  if(oRound<4){
    if(!confirm("Les 4 rondes de qualifications ne sont pas encore jouées. Continuer quand même ?")) return;
  }
  if(oTeams.length<4){ alert('Il faut au moins 4 équipes pour créer des tableaux A/B.'); return; }
  const ranked = oTeams.slice().sort((a,b)=>{
    if(b.pts!==a.pts) return b.pts-a.pts;
    const gda=a.gf-a.ga, gdb=b.gf-b.ga;
    if(gdb!==gda) return gdb-gda;
    return 0;
  });
  const n = ranked.length;
  const halfA = Math.ceil(n/2);
  const teamsA = ranked.slice(0,halfA);
  const teamsB = ranked.slice(halfA);

  function buildBracketFromTeams(list){
    if(list.length<2) return null;
    const arr=list.slice();
    const ordered=[];
    let i=0,j=arr.length-1;
    while(i<j){
      ordered.push(arr[i]); ordered.push(arr[j]);
      i++; j--;
    }
    const initialMatches=[];
    for(let k=0;k<ordered.length;k+=2){
      const A=ordered[k], B=ordered[k+1];
      if(!B) break;
      initialMatches.push({id:randId(), type:'W', round:1, teamA:A, teamB:B, scoreA:null, scoreB:null, done:false});
    }
    return { WB:{rounds:[initialMatches]}, LB:{rounds:[]}, GF:[], _pendingWB:{}, _pendingLB_fromWB:{}, _pendingLBWin:{} };
  }

  oFinals.A = buildBracketFromTeams(teamsA);
  oFinals.B = buildBracketFromTeams(teamsB);
  addHistoryEntry('OPEN','Info',"Création tableaux A ("+teamsA.length+" équipes) et B ("+teamsB.length+" équipes)", null,null);
  oRenderFinals();
}

function oTeamsToMatches(teams, roundNum, type){
  const arr=[];
  for(let i=0;i<teams.length;i+=2){
    const A=teams[i], B=teams[i+1];
    if(!B) continue;
    arr.push({id:randId(), type, round:roundNum, teamA:A, teamB:B, scoreA:null, scoreB:null, done:false});
  }
  return arr;
}

function oFindFinalMatch(bracket, uid){
  if(!bracket) return null;
  if(uid.startsWith('W')){
    const parts=uid.split('_'); const r=parseInt(parts[0].slice(1),10)-1; const id=parts[1];
    const arr=bracket.WB.rounds[r]||[]; return {match:arr.find(m=>m.id===id), bracket:'W', r};
  }
  if(uid.startsWith('L')){
    const parts=uid.split('_'); const r=parseInt(parts[0].slice(1),10)-1; const id=parts[1];
    const arr=bracket.LB.rounds[r]||[]; return {match:arr.find(m=>m.id===id), bracket:'L', r};
  }
  if(uid.startsWith('F')){
    const parts=uid.split('_'); const idx=parseInt(parts[0].slice(1),10);
    return {match:bracket.GF[idx], bracket:'F', r:idx};
  }
  return null;
}

function oSubmitFinal(which, uid){
  const bracket = which==='A' ? oFinals.A : oFinals.B;
  const meta = oFindFinalMatch(bracket, uid);
  if(!meta || !meta.match){ alert('Match introuvable.'); return; }
  const m = meta.match;
  if(m.done) return;
  const a = parseInt(el('oFA_'+which+'_'+uid).value||'0',10);
  const b = parseInt(el('oFB_'+which+'_'+uid).value||'0',10);
  if(a<11 && b<11){ alert('Un score doit atteindre 11.'); return; }
  m.scoreA=a; m.scoreB=b; m.done=true;
  const winner = a>b ? m.teamA : m.teamB;
  const loser  = a>b ? m.teamB : m.teamA;
  const phaseLabel = which==='A' ? 'Tab A' : 'Tab B';
  const brLabel = meta.bracket==='W' ? 'WB R'+(meta.r+1) : meta.bracket==='L' ? 'LB R'+(meta.r+1) : 'Finale';
  addHistoryEntry('OPEN', phaseLabel+' '+brLabel, m.teamA.name+' vs '+m.teamB.name, a,b);

  if(meta.bracket==='W'){
    bracket._pendingWB[meta.r]=bracket._pendingWB[meta.r]||[];
    bracket._pendingLB_fromWB[meta.r]=bracket._pendingLB_fromWB[meta.r]||[];
    bracket._pendingWB[meta.r].push(winner);
    bracket._pendingLB_fromWB[meta.r].push(loser);
    const allDone = bracket.WB.rounds[meta.r].every(x=>x.done);
    if(allDone) oHandleWBRoundComplete(bracket, meta.r);
  } else if(meta.bracket==='L'){
    bracket._pendingLBWin[meta.r]=bracket._pendingLBWin[meta.r]||[];
    bracket._pendingLBWin[meta.r].push(winner);
    const arr=bracket.LB.rounds[meta.r]||[];
    const allDone = arr.length>0 && arr.every(x=>x.done);
    if(allDone) oHandleLBRoundComplete(bracket, meta.r);
  } else if(meta.bracket==='F'){
    const idx = meta.r;
    if(idx===0){
      const lbWon = winner.name === m.teamB.name;
      if(lbWon){
        bracket.GF.push({id:randId(), type:'F', round:2, teamA:m.teamB, teamB:m.teamA, scoreA:null, scoreB:null, done:false});
        alert('LB gagne la première finale — deuxième finale ajoutée.');
      } else {
        alert('Vainqueur '+(which==='A'?'Tableau A':'Tableau B')+' : '+winner.name);
      }
    } else {
      alert('Vainqueur '+(which==='A'?'Tableau A':'Tableau B')+' : '+winner.name);
    }
  }
  oMaybeCreateGrandFinal(bracket);
  oRenderFinals();
}

function oHandleWBRoundComplete(bracket, roundIdx){
  const winners=(bracket._pendingWB[roundIdx]||[]).slice();
  bracket._pendingWB[roundIdx]=[];
  const nextTeams=[];
  for(let i=0;i<winners.length;i+=2){
    const t1=winners[i], t2=winners[i+1];
    if(!t1||!t2) continue;
    nextTeams.push(t1);
    nextTeams.push(t2);
  }
  if(nextTeams.length){
    bracket.WB.rounds[roundIdx+1]=bracket.WB.rounds[roundIdx+1]||[];
    bracket.WB.rounds[roundIdx+1] = bracket.WB.rounds[roundIdx+1].concat( oTeamsToMatches(nextTeams, roundIdx+2, 'W') );
  }
  const losers=(bracket._pendingLB_fromWB[roundIdx]||[]).slice();
  bracket._pendingLB_fromWB[roundIdx]=[];
  if(losers.length){
    bracket.LB.rounds[0]=bracket.LB.rounds[0]||[];
    for(let i=0;i<losers.length;i+=2){
      const aT=losers[i], bT=losers[i+1];
      if(aT && bT){
        bracket.LB.rounds[0].push({id:randId(), type:'L', round:1, teamA:aT, teamB:bT, scoreA:null, scoreB:null, done:false});
      }
    }
  }
}

function oHandleLBRoundComplete(bracket, roundIdx){
  const wins=(bracket._pendingLBWin[roundIdx]||[]).slice();
  bracket._pendingLBWin[roundIdx]=[];
  const nextTeams=[];
  for(let i=0;i<wins.length;i+=2){
    const t1=wins[i], t2=wins[i+1];
    if(!t1||!t2) continue;
    nextTeams.push(t1); nextTeams.push(t2);
  }
  if(nextTeams.length){
    bracket.LB.rounds[roundIdx+1]=bracket.LB.rounds[roundIdx+1]||[];
    bracket.LB.rounds[roundIdx+1] = bracket.LB.rounds[roundIdx+1].concat( oTeamsToMatches(nextTeams, roundIdx+2, 'L') );
  }
}

function oMaybeCreateGrandFinal(bracket){
  if(!bracket) return;
  let wbChamp=null;
  for(let r=bracket.WB.rounds.length-1;r>=0;r--){
    const rnd=bracket.WB.rounds[r]||[];
    if(rnd.length===1 && rnd[0].done){
      wbChamp = rnd[0].scoreA>rnd[0].scoreB ? rnd[0].teamA : rnd[0].teamB;
      break;
    }
  }
  let lbChamp=null;
  for(let r=bracket.LB.rounds.length-1;r>=0;r--){
    const rnd=bracket.LB.rounds[r]||[];
    if(rnd.length===1 && rnd[0].done){
      lbChamp = rnd[0].scoreA>rnd[0].scoreB ? rnd[0].teamA : rnd[0].teamB;
      break;
    }
  }
  if(wbChamp && lbChamp && (!bracket.GF || bracket.GF.length===0)){
    bracket.GF = [ {id:randId(), type:'F', round:1, teamA:wbChamp, teamB:lbChamp, scoreA:null, scoreB:null, done:false} ];
  }
}

function oForceAdvance(){
  ['A','B'].forEach(which=>{
    const bracket = which==='A'?oFinals.A:oFinals.B;
    if(!bracket) return;
    for(let r=0;r<bracket.WB.rounds.length;r++){
      const arr=bracket.WB.rounds[r]||[];
      if(arr.length>0 && arr.every(x=>x.done)) oHandleWBRoundComplete(bracket,r);
    }
    for(let r=0;r<bracket.LB.rounds.length;r++){
      const arr=bracket.LB.rounds[r]||[];
      if(arr.length>0 && arr.every(x=>x.done)) oHandleLBRoundComplete(bracket,r);
    }
    oMaybeCreateGrandFinal(bracket);
  });
  oRenderFinals();
}

function oRenderFinals(){
  const node=el('openFinalsArea'); node.innerHTML='';
  function renderBracket(bracket, which){
    if(!bracket){
      node.innerHTML += `<div class="muted">Tableau ${which} non initialisé.</div>`;
      return;
    }
    bracket.WB.rounds.forEach((rnd,ri)=>{
      const r=ri+1;
      rnd.forEach((m,mi)=>{
        const uid=`W${r}_${m.id}`;
        const div=document.createElement('div'); div.className='match';
        div.innerHTML=`<div><span class="badge">[OPEN ${which} WB R${r} - Match ${mi+1}]</span> ${m.teamA.name} vs ${m.teamB.name}</div>`;
        const actions=document.createElement('div'); actions.className='row';
        if(!m.done){
          actions.innerHTML=`<input id="oFA_${which}_${uid}" type="number" min="0" placeholder="0"> - 
            <input id="oFB_${which}_${uid}" type="number" min="0" placeholder="0">
            <button>Valider</button>`;
          actions.querySelector('button').onclick=()=>oSubmitFinal(which,uid);
        } else {
          actions.innerHTML=`<div class="muted">Score: ${m.scoreA} - ${m.scoreB}</div>`;
        }
        div.appendChild(actions); node.appendChild(div);
      });
    });
    bracket.LB.rounds.forEach((rnd,ri)=>{
      const r=ri+1;
      rnd.forEach((m,mi)=>{
        const uid=`L${r}_${m.id}`;
        const div=document.createElement('div'); div.className='match';
        div.innerHTML=`<div><span class="badge">[OPEN ${which} LB R${r} - Match ${mi+1}]</span> ${m.teamA.name} vs ${m.teamB.name}</div>`;
        const actions=document.createElement('div'); actions.className='row';
        if(!m.done){
          actions.innerHTML=`<input id="oFA_${which}_${uid}" type="number" min="0" placeholder="0"> - 
            <input id="oFB_${which}_${uid}" type="number" min="0" placeholder="0">
            <button class="warn">Valider</button>`;
          actions.querySelector('button').onclick=()=>oSubmitFinal(which,uid);
        } else {
          actions.innerHTML=`<div class="muted">Score: ${m.scoreA} - ${m.scoreB}</div>`;
        }
        div.appendChild(actions); node.appendChild(div);
      });
    });
    (bracket.GF||[]).forEach((m,idx)=>{
      const uid=`F${idx}_${m.id}`;
      const div=document.createElement('div'); div.className='match';
      div.innerHTML=`<div><span class="badge">[OPEN ${which} GF - Match ${idx+1}]</span> ${m.teamA.name} vs ${m.teamB.name}</div>`;
      const actions=document.createElement('div'); actions.className='row';
      if(!m.done){
        actions.innerHTML=`<input id="oFA_${which}_${uid}" type="number" min="0" placeholder="0"> - 
          <input id="oFB_${which}_${uid}" type="number" min="0" placeholder="0">
          <button>Valider</button>`;
        actions.querySelector('button').onclick=()=>oSubmitFinal(which,uid);
      } else {
        actions.innerHTML=`<div class="muted">Score: ${m.scoreA} - ${m.scoreB}</div>`;
      }
      div.appendChild(actions); node.appendChild(div);
    });
  }
  node.innerHTML += '<h3>Tableau A</h3>';
  renderBracket(oFinals.A,'A');
  node.innerHTML += '<h3>Tableau B</h3>';
  renderBracket(oFinals.B,'B');
  el('debugBox').textContent = 'OPEN FINALS STATE:\\nA='+JSON.stringify(oFinals.A,null,2)+'\\nB='+JSON.stringify(oFinals.B,null,2);
}

// ----------- INIT & BINDINGS -----------
document.addEventListener('DOMContentLoaded', ()=>{
  el('btnModeDYP').onclick = ()=> showMode('dyp');
  el('btnModeOpen').onclick = ()=> showMode('open');

  el('dypBtnAdd').onclick = ()=>{
    const name = el('dypPlayerName').value.trim();
    const role = el('dypPlayerRole').value;
    if(!name){ alert('Nom requis'); return; }
    if(dPlayers.some(p=>p.name.toLowerCase()===name.toLowerCase())){ alert('Joueur déjà inscrit'); return; }
    dPlayers.push({name,role});
    dEnsurePlayer(name);
    el('dypPlayerName').value='';
    dRenderPlayers(); dRenderRanking();
  };
  el('dypBtnReset').onclick = ()=>{
    if(!confirm('Réinitialiser complètement le mode DYP ?')) return;
    dPlayers=[]; dStats={}; dRound=0; dMatches=[]; dUsedPairs={}; dUsedMatchups={}; dFinals=null;
    el('dypRoundInfo').textContent='';
    el('dypQualifMatches').innerHTML='';
    el('dypFinalsArea').innerHTML='';
    dRenderPlayers(); dRenderRanking();
    el('debugBox').textContent='--';
  };
  el('dypBtnNewRound').onclick = dGenerateRound;
  el('dypBtnStartFinals').onclick = dStartFinals;
  el('dypBtnForceNext').onclick = dForceAdvance;
  dRenderPlayers(); dRenderRanking();

  el('openBtnAdd').onclick=()=>{
    const name=el('openTeamName').value.trim();
    if(!name){ alert("Nom d'équipe requis"); return; }
    if(oTeams.some(t=>t.name.toLowerCase()===name.toLowerCase())){ alert('Équipe déjà inscrite'); return; }
    oTeams.push({name:name,byeCount:0,pts:0,gf:0,ga:0});
    el('openTeamName').value='';
    oRenderTeams(); oRenderRanking();
  };
  el('openBtnReset').onclick=()=>{
    if(!confirm('Réinitialiser complètement le mode Open Double ?')) return;
    oTeams=[]; oRound=0; oMatches=[]; oUsedMatchups={}; oFinals={A:null,B:null};
    el('openRoundInfo').textContent='';
    el('openQualifMatches').innerHTML='';
    el('openFinalsArea').innerHTML='';
    oRenderTeams(); oRenderRanking();
    el('debugBox').textContent='--';
  };
  el('openBtnNewRound').onclick = oGenerateSwissRound;
  el('openBtnStartFinals').onclick = oCreateFinals;
  el('openBtnForceNext').onclick = oForceAdvance;
  oRenderTeams(); oRenderRanking();

  el('btnToggleHistory').onclick = ()=>{
    const panel = el('historyPanel');
    panel.style.display = (panel.style.display==='none' || panel.style.display==='') ? 'block' : 'none';
  };
  renderGlobalHistory();
});
</script>
</body>
</html>
